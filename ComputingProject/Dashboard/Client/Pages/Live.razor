@page "/telemetrylive"
@using Dashboard.Client.Adapters;
@using Google.Protobuf.WellKnownTypes;
@using Microsoft.Fast.Components.FluentUI
@using Dashboard.Client.Components
@using Dashboard.Shared.GrpcProto
@using Grpc.Core
@using Dashboard.Client.Enums
@using Dashboard.Client.Services
@using Dashboard.Shared.Models
@using System.Text.Json;

@inject IJSRuntime JsRuntime
@inject TelemetryData.TelemetryDataClient TelemetryClient

<PageTitle>Live Telemetry</PageTitle>
<div class="telemetry-container">
    <ButtonBanner OnStartClicked="StartClicked" OnStopClicked="StopClicked" OnStartRecordClicked="StartRecordingClicked" OnStopRecordClicked="StopRecordingClicked"/>
    <TelemetryDashboard @ref="dashboard" />
    <ParameterList Connection="connection" Recording="recording" OnAddFakeDataLogs="AddFakeDataLogsClicked" OnClearFakeDataLogs="ClearFakeDataLogsClicked" OnAddFakeDataPoints="AddFakeDataPointsClicked"
       OnClearFakeDataPoints="ClearFakeDataPointsClicked" />
    <TelemetryLog @ref="log" />
</div>

@code {
    AsyncServerStreamingCall<Data>? stream;
    HashSet<string>? parameters = new HashSet<string>();

    TelemetryDashboard? dashboard;
    TelemetryLog? log;

    ConnectionStatus connection = ConnectionStatus.Disconnected;
    RecordingStatus recording = RecordingStatus.NotRecoding;

    private Random rnd = new Random();

    // Need to clean this code. More consistent types etc. 
    // There is a bug when the stream is stopped and started again, nothing happens and it needs to be started/stopped multiple times for data to start going through
    // again.

    // Parameter names need to be fixed, where the parameter name and units are shown nicer.

    // gRPC needs to be removed from server side and its easier to just use it straight from the client.
    // CORS needs to be sorted properly.
    public async Task StartClicked()
    {
        try
        {
            connection = ConnectionStatus.Connecting;
            StateHasChanged();
            using (stream = TelemetryClient.OpenTelemetryStream(new Empty()))
            {
                await foreach(var response in stream.ResponseStream.ReadAllAsync())
                {
                    connection = ConnectionStatus.Connected;
                    StateHasChanged();
                    // gRPC server has already ensured the messages are in the right format.
                    Console.WriteLine($"Parameter: {response.Parameter} | Unit: {response.Unit} | Value: {response.Value} | Timestamp: {response.Timestamp}");

                    var time = long.Parse(response.Timestamp);

                    // Pass response to Chart Service to have it displayed.
                    var colorString = $"rgb({rnd.Next(256)}, {rnd.Next(256)}, {rnd.Next(256)})";
                    Parameter p = new Parameter(response.Parameter + " (" + response.Unit + ")", 1, colorString, colorString);
                    //DateTimeOffset time = DateTimeOffset.Parse(response.Timestamp);
                    ParameterData pd = new ParameterData(response.Value.ToString(), time);

                    // Handle if its a log message
                    if (response.Unit.Equals("log"))
                    {
                        p.Label = response.Parameter;
                        log.addLog(p, pd.Value, time);
                        continue;
                    }

                    // Checking label isnt the best but itll work. Having a HashSet<Parameter> doesnt work with contains as it seems like its checking object references
                    // insead of the members of the object.
                    if (!parameters.Contains(p.Label))
                    {
                        parameters.Add(p.Label);
                        await ChartService.AddParameter(JsonSerializer.Serialize(p), JsRuntime);
                    }

                    // Unlike Parameter, ParameterData doesnt need to be serialised before its passsed into the JS function. This should be more consistent.
                    await ChartService.AddParameterData(p.Label ,pd, JsRuntime);
                }
                connection = ConnectionStatus.Disconnected;
            }
        } catch(Grpc.Core.RpcException ex) when (ex.StatusCode == StatusCode.Cancelled)
        {
            connection = ConnectionStatus.Disconnected;
            Console.WriteLine("Stream cancelled");
        }
        catch (Exception ex) 
        { 
            connection = ConnectionStatus.Disconnected;
            Console.WriteLine("Error: Disconnecting...");
            Console.WriteLine(ex);
        }
    }

    public void StopClicked()
    {
        connection = ConnectionStatus.Disconnected;
        stream?.Dispose();
    }

    public async Task StartRecordingClicked()
    {
        recording = RecordingStatus.Recording;
        await TelemetryClient.RecordTelemetryAsync(new RecordTelemetryMessage { RecordingStatus = RecordingStatusAdapter.ToGrpcRecordingStatus(recording) });
    }

    public async Task StopRecordingClicked()
    {
        recording = RecordingStatus.NotRecoding;
        await TelemetryClient.RecordTelemetryAsync(new RecordTelemetryMessage { RecordingStatus = RecordingStatusAdapter.ToGrpcRecordingStatus(recording) });
    }

    public void AddFakeDataLogsClicked()
    {
        //log?.addFakeLogs();
    }

    public void ClearFakeDataLogsClicked()
    {
        log?.clearLogs();
    }

    public void AddFakeDataPointsClicked()
    {

        dashboard?.AddFakeDataPoints();
    }

    public void ClearFakeDataPointsClicked()
    {
        dashboard?.ClearDataPoints();
    }
}