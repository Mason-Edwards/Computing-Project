@page "/telemetryhistorical"
@using Dashboard.Client.Adapters;
@using Google.Protobuf.WellKnownTypes;
@using Microsoft.Fast.Components.FluentUI
@using Dashboard.Client.Components
@using Dashboard.Shared.GrpcProto
@using Grpc.Core
@using Dashboard.Client.Enums
@using Dashboard.Client.Services
@using Dashboard.Shared.Models
@using System.Text.Json;

@inject IJSRuntime JsRuntime
@inject TelemetryData.TelemetryDataClient TelemetryClient

<PageTitle>Live Telemetry</PageTitle>
<div class="telemetry-container">
    <ButtonBanner OnLoadDataClicked="LoadDataClicked"/>
    <TelemetryDashboard @ref="dashboard" />
    <ParameterList Connection="connection" Recording="recording" OnAddFakeDataLogs="AddFakeDataLogsClicked" OnClearFakeDataLogs="ClearFakeDataLogsClicked" OnAddFakeDataPoints="AddFakeDataPointsClicked"
       OnClearFakeDataPoints="ClearFakeDataPointsClicked" />
    <TelemetryLog @ref="log" />
</div>

@code {
    AsyncServerStreamingCall<Data>? stream;
    HashSet<string>? parameters = new HashSet<string>();

    TelemetryDashboard? dashboard;
    TelemetryLog? log;

    ConnectionStatus connection = ConnectionStatus.Disconnected;
    RecordingStatus recording = RecordingStatus.NotRecoding;

    // Need to clean this code. More consistent types etc. 
    // There is a bug when the stream is stopped and started again, nothing happens and it needs to be started/stopped multiple times for data to start going through
    // again.

    // Parameter names need to be fixed, where the parameter name and units are shown nicer.

    // gRPC needs to be removed from server side and its easier to just use it straight from the client.
    // CORS needs to be sorted properly.

    public async Task LoadDataClicked()
    {
        var start = await JsRuntime.InvokeAsync<string>("GetStartDate");
        var end = await JsRuntime.InvokeAsync<string>("GetEndDate");

        if (start == "" || end == "") 
        {
            await JsRuntime.InvokeVoidAsync("alert", "ERROR: Start or End time not selected!");
            return;
        }

        var startParsed = DateTimeOffset.Parse(start);
        var startToUnix = startParsed.ToUnixTimeSeconds();

        var endParsed = DateTimeOffset.Parse(end);
        var endToUnix = endParsed.ToUnixTimeSeconds();

        if(startToUnix > endToUnix)
        {
            await JsRuntime.InvokeVoidAsync("alert", "ERROR: End time is before start time!");
            return;
        }

        LoadTelemetryDataReply data = await TelemetryClient.LoadTelemetryDataAsync(new LoadTelemetryDataRequest() { Start = startToUnix, End = endToUnix });

        for (int i = 0; i < data.DataList.Count; i++)
        {
            var test = data.DataList.ElementAt(i);
            if (!parameters.Contains(test.Parameter))
            {
                Parameter p = new Parameter($"{test.Parameter}", 1, "rgb(255, 0, 0)", "rgba(255, 0, 0, 1)");
                string pSerialised = JsonSerializer.Serialize(p);
                parameters.Add(test.Parameter);

                await JsRuntime.InvokeAsync<string>("addNewParameter", pSerialised);
            }

            ParameterData pd = new ParameterData(test.Value.ToString(), DateTimeOffset.Parse(test.Timestamp).ToUnixTimeMilliseconds());
            await JsRuntime.InvokeAsync<string>("addData", test.Parameter, pd);
        }

        await JsRuntime.InvokeAsync<string>("scaleChartXAxis");
    }

    public void AddFakeDataLogsClicked()
    {
        log?.addFakeLogs();
    }

    public void ClearFakeDataLogsClicked()
    {
        log?.clearLogs();
    }

    public void AddFakeDataPointsClicked()
    {

        dashboard?.AddFakeDataPoints();
    }

    public void ClearFakeDataPointsClicked()
    {
        dashboard?.ClearDataPoints();
    }
}